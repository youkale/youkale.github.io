<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta http-equiv=content-security-policy content="upgrade-insecure-requests; block-all-mixed-content; default-src 'self'; child-src 'self'; font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net/; form-action 'self'; frame-src 'self'; img-src 'self'; object-src 'none'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com/ https://cdn.jsdelivr.net/; script-src 'self' 'unsafe-inline' https://www.google-analytics.com https://cdn.jsdelivr.net/; prefetch-src 'self'; connect-src 'self' https://www.google-analytics.com;"><meta name=author content="Youkale"><meta name=description content="TCP 连接优化、池化"><meta name=keywords content="rest,kafka,clojure,golang,redis,程序员,developer,数据集成,pipeline,rule engine"><meta name=twitter:card content="summary"><meta name=twitter:title content="线上服务器TCP连接相关优化"><meta name=twitter:description content="TCP 连接优化、池化"><meta property="og:title" content="线上服务器TCP连接相关优化"><meta property="og:description" content="TCP 连接优化、池化"><meta property="og:type" content="article"><meta property="og:url" content="https://youkale.github.io/posts/online-server-tcp-connect-optimization/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-06T12:32:29+08:00"><meta property="article:modified_time" content="2022-06-06T12:32:29+08:00"><title>(-> c r u d)</title><link rel=canonical href=https://youkale.github.io/posts/online-server-tcp-connect-optimization/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css integrity="sha256-axpPvEiVW3Kup5E+Q/q+tF6LwSDaWqQbWY3TOtysS1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.107.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>(-> c r u d)</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/bookmark/>收藏</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://youkale.github.io/posts/online-server-tcp-connect-optimization/>线上服务器TCP连接相关优化</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-06-06T12:32:29+08:00>2022-06-06</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i></span></div><div class=authors><i class="fa fa-user" aria-hidden=true></i>
<a href=/authors/youkale/>Youkale</a></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/tcp/>TCP</a></span></div></div></header><div><h1 id=线上服务器tcp连接相关>线上服务器TCP连接相关
<a class=heading-link href=#%e7%ba%bf%e4%b8%8a%e6%9c%8d%e5%8a%a1%e5%99%a8tcp%e8%bf%9e%e6%8e%a5%e7%9b%b8%e5%85%b3><i class="fa fa-link" aria-hidden=true></i></a></h1><hr><h3 id=为什么优化点在网络>为什么优化点在网络？
<a class=heading-link href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%98%e5%8c%96%e7%82%b9%e5%9c%a8%e7%bd%91%e7%bb%9c><i class="fa fa-link" aria-hidden=true></i></a></h3><p>随着云平台的兴起, 传统自建数据库或者其他业务中间件的情况会比较少，而我们系统也主要集中在调用平台提供的服务。</p><p>因此今天主要讲的是网络相关内容。</p><h3 id=tcp-4次挥手>TCP-4次挥手
<a class=heading-link href=#tcp-4%e6%ac%a1%e6%8c%a5%e6%89%8b><i class="fa fa-link" aria-hidden=true></i></a></h3><pre tabindex=0><code class=language-sequence data-lang=sequence>alice --&gt; bob: FIN [1]
alice --&gt; alice: FIN_WAIT_1 [2] 
bob -- alice: ACK [3]
alice -- alice: FIN_WAIT_2
bob --&gt; bob: CLOSE_WAIT
bob --&gt; alice: FIN ACK
bob --&gt; bob: LAST_ACK
alice --&gt; bob: ACK
alice -- alice: TIME_WAIT, 等待2MSL
bob --&gt; bob: 关闭
alice --&gt; alice: 2MSL关闭
</code></pre><pre tabindex=0><code>alice -&gt; bob: 分手吧。 (fin_wait_1)
bob -&gt; alice: ok (close_wait)
alice: (fin_wait_2)
bob -&gt; alice: 来呀，分手吧, (last_ack)
alice -&gt; bob: ok ，(TIME-WAIT + 2MSL)
bob: CLOSE
</code></pre><h3 id=为什么在排查tcp连接的时候要去检查time-wait>为什么在排查TCP连接的时候要去检查TIME-WAIT?
<a class=heading-link href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%9c%a8%e6%8e%92%e6%9f%a5tcp%e8%bf%9e%e6%8e%a5%e7%9a%84%e6%97%b6%e5%80%99%e8%a6%81%e5%8e%bb%e6%a3%80%e6%9f%a5time-wait><i class="fa fa-link" aria-hidden=true></i></a></h3><ul><li>可用端口数量是有限的, <code>cat /proc/sys/net/ipv4/ip_local_port_range</code></li></ul><pre tabindex=0><code>   cat /proc/sys/net/ipv4/ip_local_port_range
   32768   60999
</code></pre><ul><li>2MSL：表示段的最大生命周期，一般为2分钟(2 * 60s), 可以通过 <code>cat /proc/sys/net/ipv4/tcp_fin_timeout</code>进行查看</li></ul><blockquote><p>因此如果存在大量的timewait表示可用的连接减少，同时占用着资源，无法应对突发流量。</p></blockquote><h3 id=获取相关信息>获取相关信息：
<a class=heading-link href=#%e8%8e%b7%e5%8f%96%e7%9b%b8%e5%85%b3%e4%bf%a1%e6%81%af><i class="fa fa-link" aria-hidden=true></i></a></h3><ul><li><p>查看内核参数: <code>sysctl -p |grep net</code></p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iz8vb3gm51vgkvb60twt46z ~<span style=color:#f92672>]</span><span style=color:#75715e># sysctl -p |grep net</span>
</span></span><span style=display:flex><span>net.ipv4.tcp_max_tw_buckets <span style=color:#f92672>=</span> <span style=color:#ae81ff>10000</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div></li></ul></li><li><p>统计TCP：</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>   <span style=color:#f92672>[</span>root@iz8vb3gm51vgkvb60twt46z ~<span style=color:#f92672>]</span><span style=color:#75715e># ss -nat |awk &#39;{x[$1] +=1}END{for(i in x) print i,x[i]}&#39;</span>
</span></span><span style=display:flex><span>   LISTEN <span style=color:#ae81ff>13</span>
</span></span><span style=display:flex><span>   ESTAB <span style=color:#ae81ff>333</span>
</span></span><span style=display:flex><span>   CLOSE-WAIT <span style=color:#ae81ff>281</span>
</span></span><span style=display:flex><span>   State <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>   TIME-WAIT <span style=color:#ae81ff>9530</span>
</span></span></code></pre></div><ul><li>产生服务器：<code>ss -nat | awk '/TIME-WAIT/ {print $5}' | awk -F ":" '{x[$1]+=1} END {for(i in x) print i, x[i]}'</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span> <span style=color:#f92672>[</span>root@iz8vb3gm51vgkvb60twt46z ~<span style=color:#f92672>]</span><span style=color:#75715e># ss -nat | awk &#39;/TIME-WAIT/ {print $5}&#39; | awk  -F &#34;:&#34; &#39;{x[$1]+=1} END {for(i in x) print i, x[i]}&#39;</span>
</span></span><span style=display:flex><span> 106.11.208.135 <span style=color:#ae81ff>46</span>
</span></span><span style=display:flex><span> 14.119.64.132 <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span> 14.119.64.133 <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span> 14.215.62.21 <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span> 14.215.62.24 <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span> 101.89.47.18 <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span> 221.130.19.101 <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span> 203.119.169.6 <span style=color:#ae81ff>148</span>
</span></span><span style=display:flex><span> ....
</span></span></code></pre></div><p>通过查看内核参数<code>net.ipv4.tcp_max_tw_buckets</code> 得知当前服务器最大time-wait数量为: <code>10000</code></p><p>通过<code>cat /proc/sys/net/ipv4/ip_local_port_range</code>实际可用端口数为: <code>61000 - 32768 = 28231</code></p><h3 id=解决方法>解决方法
<a class=heading-link href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95><i class="fa fa-link" aria-hidden=true></i></a></h3><ul><li><p>将time-wait留在客户端。（需要代码调整）</p></li><li><p>连接池化。(需要代码调整）</p></li><li><p>调整<code>tcp_max_tw_buckets</code> 在可用端口数范围内. (保证足够可用内存, 没有新的请求)</p></li><li><p>启用<code>net.ipv4.tcp_tw_reuse</code>, 该选项可用将进入到time-wait状态的连接重复使用。默认该选项是关闭的。</p><blockquote><p>RFC1323 提出了一组TCP扩展，以改善高带宽路径的性能。除其他外，它定义了一个新的TCP选项，携带两个四字节的时间戳字段。第一个是发送该选项的TCP的时间戳时钟的当前值，而第二个则是从远程主机收到的最新时间戳。</p><p>通过启用net.ipv4.tcp_tw_reuse，如果新的时间戳严格大于前一个连接记录的最新时间戳，Linux将重新使用一个处于TIME-WAIT状态的现有连接，用于新的出站连接：一个处于TIME-WAIT状态的出站连接可以在短短一秒钟后被重新使用。</p></blockquote><ul><li>另外改选项生效需要配合 <code>net.ipv4.tcp_timestamps</code> 参数才能生效。<ul><li>正常情况下新连接的发送时间都大于之前一个连接的时间戳，不知道是否有其他情况。</li><li>该参数是TCP的一个扩展，分别记录发送时间戳和从远程服务器收到时间戳</li><li>在<code>tcp_tw_resuse</code>不生效的时候，可以看看远程服务器是否开启。</li></ul></li></ul></li></ul><h3 id=错误方法>错误方法
<a class=heading-link href=#%e9%94%99%e8%af%af%e6%96%b9%e6%b3%95><i class="fa fa-link" aria-hidden=true></i></a></h3><ul><li><p>打开 <code>net.ipv4.tcp_tw_recycle</code></p><blockquote><p>当远程主机是一个NAT设备时，关于时间戳的条件将禁止所有的主机在一分钟内连接，除了NAT设备后面的一台，因为它们不共享相同的时间戳时钟。如果有疑问，最好禁用这个选项，因为它导致了难以检测和难以诊断的问题。</p></blockquote><ul><li>该参数在新版的内核中已经移除</li></ul></li></ul><h2 id=线上服务错误的连接断开>线上服务错误的连接断开
<a class=heading-link href=#%e7%ba%bf%e4%b8%8a%e6%9c%8d%e5%8a%a1%e9%94%99%e8%af%af%e7%9a%84%e8%bf%9e%e6%8e%a5%e6%96%ad%e5%bc%80><i class="fa fa-link" aria-hidden=true></i></a></h2><h3 id=问题>问题：
<a class=heading-link href=#%e9%97%ae%e9%a2%98><i class="fa fa-link" aria-hidden=true></i></a></h3><blockquote><p>在通过服务器调用远程某服务的时候，经常性出现<code>Read Timeout</code>.
Read timed out 是在调用socket read后，指定时间内未收到响应时 jdk抛出的异常， 比如: http response size = 10k, socket read = 4k, read timeout = 3s，那么每次读取限于3秒内读取完毕。简单理解就是在(e)poll的间隔时间.</p></blockquote><ul><li>通过<code>curl</code>对远程服务进行请求，发现请求正常，并未出现<code>Read Timeout</code>. 基本可以判断并非服务器内核参数问题.</li><li>通过tcpdump抓包: <code>tcpdump -i eth0 'port 80' -w 1.cap</code></li></ul><blockquote><p>从蓝色部分来看，客户端发出请求到服务器80端口后，并未收到响应，连接非正常关闭了。
<img src=/images/online-server-1.png alt=online-server-1>
而这个从80端口返回的包，刚好上上一个连接错误断开后返回的。因为本地的连接已经销毁了，通过4元组已经找不到对应的连接，于是客户端-rst->服务80.
<img src=/images/online-server-2.png alt=online-server-2>
这个图能直观看出之间的通信，左边80代表服务端口，右边代表客户端端口。
<img src=/images/online-server-3.png alt=online-server-3></p></blockquote><h3 id=解决方法-1>解决方法:
<a class=heading-link href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95-1><i class="fa fa-link" aria-hidden=true></i></a></h3><blockquote><p>在使用 <code>WebUtil.doPostJson</code> 方法时候，使用默认不带<code>readTimeout</code>参数的方法的时候，会默认使用<code>60s</code>超时的读取超时时间。</p></blockquote><ul><li><p>使用带超时时间重载的方法，并设置超时时间为<code>0</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>doPostJson<span style=color:#f92672>(</span>String url<span style=color:#f92672>,</span> String json<span style=color:#f92672>,</span> String charset<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> connectTimeout<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> readTimeout<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    Map<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>,</span> String<span style=color:#f92672>&gt;</span> headerMap<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> IOException 
</span></span></code></pre></div></li></ul><h2 id=常见httpclient优化方法>常见HttpClient优化方法
<a class=heading-link href=#%e5%b8%b8%e8%a7%81httpclient%e4%bc%98%e5%8c%96%e6%96%b9%e6%b3%95><i class="fa fa-link" aria-hidden=true></i></a></h2><ul><li>Http连接管理 <code>PoolingHttpClientConnectionManager</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>PoolingHttpClientConnectionManager connManager 
</span></span><span style=display:flex><span>  <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PoolingHttpClientConnectionManager<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>connManager<span style=color:#f92672>.</span><span style=color:#a6e22e>setMaxTotal</span><span style=color:#f92672>(</span><span style=color:#ae81ff>5</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>connManager<span style=color:#f92672>.</span><span style=color:#a6e22e>setDefaultMaxPerRoute</span><span style=color:#f92672>(</span><span style=color:#ae81ff>4</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>HttpHost host <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HttpHost<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;www.baidu.com&#34;</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>80</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>connManager<span style=color:#f92672>.</span><span style=color:#a6e22e>setMaxPerRoute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> HttpRoute<span style=color:#f92672>(</span>host<span style=color:#f92672>),</span> <span style=color:#ae81ff>5</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><ul><li>使用请求重试 <code>HttpRequestRetryHandler</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> CloseableHttpClient httpclient <span style=color:#f92672>=</span> HttpClients<span style=color:#f92672>.</span><span style=color:#a6e22e>custom</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>.</span><span style=color:#a6e22e>setRetryHandler</span><span style=color:#f92672>(</span>retryHandler<span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>.</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> HttpRequestRetryHandler  <span style=color:#a6e22e>retryHandler</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=参考>参考
<a class=heading-link href=#%e5%8f%82%e8%80%83><i class="fa fa-link" aria-hidden=true></i></a></h2><ul><li><a href=https://datatracker.ietf.org/doc/html/rfc1323>RFC1323</a></li><li><a href=https://hoswey.github.io/2019/07/23/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84TCP%E8%B6%85%E6%97%B6/>浅谈Java中的TCP超时</a></li><li><a href=https://www.jianshu.com/p/ade80fe11f58>HttpClient RetryHandler</a></li><li><a href=https://www.baeldung.com/httpclient-connection-management>Apache HttpClient Example</a></li></ul></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2022
Youkale
·
<a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js integrity="sha256-I2BJOV3DaC+ycZZAhylY4S8fJAZ7sJwyeyM+YpDH7aw="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-H9CHLFCJFP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-H9CHLFCJFP")</script></body></html>