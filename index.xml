<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>(-> c r u d)</title><link>https://youkale.github.io/</link><description>Recent content on (-> c r u d)</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sat, 11 Jun 2022 12:32:29 +0800</lastBuildDate><atom:link href="https://youkale.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>收藏</title><link>https://youkale.github.io/bookmark/</link><pubDate>Fri, 01 Jul 2022 09:34:29 +0000</pubDate><guid>https://youkale.github.io/bookmark/</guid><description> 值得细读 认清性能问题 收藏的博客 伊洪-github 大连一个大佬 王垠 王垠的博客 Anthony Fu 搞文言文语言的那个大佬 酷壳 左耳朵耗子的博客 面向信仰 Golang、K8s还有其他各种不错博客的大佬 No Headback Golang、哲学流派 鸟窝 Golang、网络编程相关 庄周梦蝶 Clojure、Golang、Ruby相关 Keep Coding-刘家财 Java、clojure相关的一个技术博客 迟大 迟大、一个写数据库的大佬 青岛红创 一个抠脚/Java博客 收藏的站点 英语句型分析 explain-shell shell 执行计划，类似SQL的explain 制作Logo shodan</description></item><item><title>SSH常见用法</title><link>https://youkale.github.io/posts/ssh_cmd_example/</link><pubDate>Sat, 11 Jun 2022 12:32:29 +0800</pubDate><guid>https://youkale.github.io/posts/ssh_cmd_example/</guid><description>分享一些常见用法，希望能在工作中能提高效率。
涵盖以下内容: .ssh/config 配置
常用映射
远程-&amp;gt;本地 -L 本地-&amp;gt;远程 -R 动态代理 -D 其他ssh命令集
scp ssh-copy-id ssh-keygen .ssh/config配置简要说明 ### ----------- ~/.ssh/config ----------- ## 你配置的服务器名称，可根据自己的喜好配置, 我这里配置的是 server_1 Host server_1 ## ip 或者 domain, 可以访问的地址 HostName 223.5.5.5 ## 默认使用的用户名 User ubuntu ## 服务器端口 Port 22 ## rsa私钥地址 IdentityFile ~/.ssh/server_rsa ## 代理配置, 表示通过本地 socksv5 服务器进行代理 ProxyCommand nc -X 5 -x 127.0.0.1:8106 %h %p ### 接下来可以直接在终端下面这样使用: ### ----------- 使用方法 ----------- ### 使用上面配置的 server_1 ~$ ssh server_1 跳板机例子: ### ----------- ~/.</description></item><item><title>线上服务器TCP连接相关优化</title><link>https://youkale.github.io/posts/online-server-tcp-connect-optimization/</link><pubDate>Mon, 06 Jun 2022 12:32:29 +0800</pubDate><guid>https://youkale.github.io/posts/online-server-tcp-connect-optimization/</guid><description>线上服务器TCP连接相关 为什么优化点在网络？ 随着云平台的兴起, 传统自建数据库或者其他业务中间件的情况会比较少，而我们系统也主要集中在调用平台提供的服务。
因此今天主要讲的是网络相关内容。
TCP-4次挥手 alice --&amp;gt; bob: FIN [1] alice --&amp;gt; alice: FIN_WAIT_1 [2] bob -- alice: ACK [3] alice -- alice: FIN_WAIT_2 bob --&amp;gt; bob: CLOSE_WAIT bob --&amp;gt; alice: FIN ACK bob --&amp;gt; bob: LAST_ACK alice --&amp;gt; bob: ACK alice -- alice: TIME_WAIT, 等待2MSL bob --&amp;gt; bob: 关闭 alice --&amp;gt; alice: 2MSL关闭 alice -&amp;gt; bob: 分手吧。 (fin_wait_1) bob -&amp;gt; alice: ok (close_wait) alice: (fin_wait_2) bob -&amp;gt; alice: 来呀，分手吧, (last_ack) alice -&amp;gt; bob: ok ，(TIME-WAIT + 2MSL) bob: CLOSE 为什么在排查TCP连接的时候要去检查TIME-WAIT?</description></item><item><title>如何设计RESTful API</title><link>https://youkale.github.io/posts/how-to-design-restful-api/</link><pubDate>Sat, 21 May 2022 12:32:29 +0800</pubDate><guid>https://youkale.github.io/posts/how-to-design-restful-api/</guid><description>什么是REST Wiki中REST全称是 (Representational State Transfer) &amp;ldquo;表现层状态转换&amp;rdquo;, 也有翻译是“表征状态转移”，是Roy Thomas Fielding博士在2000年提出的一种基于Http协议的软件架构风格。表征状态转移,听起来很晦涩，是因为前面主语 Resource 被去掉了，真正的全称是 Resource Representational State Transfer 也就是: 资源在网络中以某种表现形式进行状态转移。
Resource：资源，即数据（前面说过网络的核心）。比如 users，corp等； Representational：某种表现形式，比如用JSON，XML，JPEG等； State Transfer：状态变化。通过HTTP动词实现。 REST等级 Level-0 The Ramp of Plain Old XML 说明 服务端使用统一的请求路径，通过请求体中某个字段定义业务类型，需要定义错误码。
调用 对照文档中 action 类型进行传参, 同时对响应错误码进行处理。
POST /server Content-Type: Application/json { &amp;#34;action&amp;#34;:&amp;#34;001&amp;#34;, &amp;#34;data&amp;#34;: { &amp;#34;username&amp;#34;:&amp;#34;...&amp;#34;, } } ----- Response ----- Status: 200 Content-Type: application/json { &amp;#34;status&amp;#34;: &amp;#34;A00001&amp;#34; &amp;#34;data&amp;#34;: { .... } } Level-1 Resource: 引入资源的RPC 说明 在微服务盛行的今天，引入了URI，方便网关层对请求进行转发，同时能通过URI能反映出对应的业务，需要定义错误码。
调用 对照文档中资源动作，进行传递参数，同时对响应错误码进行处理。</description></item><item><title>Vue3 Typescript LogicFlow 通过H函数自定义HTML节点</title><link>https://youkale.github.io/posts/vue3-ts-logicflow-custorm-html-node/</link><pubDate>Mon, 21 Mar 2022 12:32:29 +0800</pubDate><guid>https://youkale.github.io/posts/vue3-ts-logicflow-custorm-html-node/</guid><description> 问题 在使用DiDi的LogicFlow中，因为使用的是最新的VUE3+TS，官方没有相关的文档，在自定义HTML Node的时候碰到了一下问题，最终通过翻阅VUE3的文档找到了如下的解决方法
import { HtmlNode, HtmlNodeModel } from &amp;#39;@logicflow/core&amp;#39;; import { defineComponent, h, render as vueRender } from &amp;#39;vue&amp;#39;; import { Button, Card } from &amp;#39;ant-design-vue&amp;#39;; const myHtmlNode = defineComponent({ name: &amp;#39;MyHtmlNode&amp;#39;, components: { &amp;#39;a-button&amp;#39;: Button, //需要重新引入组件 &amp;#39;a-card&amp;#39;: Card, //需要重新引入组件 }, template: ` &amp;lt;div&amp;gt; &amp;lt;a-button type=&amp;#34;primary&amp;#34; @click=&amp;#34;handle(&amp;#39;plus&amp;#39;)&amp;#34;&amp;gt;+&amp;lt;/a-button&amp;gt; &amp;lt;a-button type=&amp;#34;dashed&amp;#34; @click=&amp;#34;handle(&amp;#39;sub&amp;#39;) &amp;#34;&amp;gt;-&amp;lt;/a-button&amp;gt; &amp;lt;/div&amp;gt; `, setup() const _handleClick = (action) =&amp;gt; { console.log(`action ....${action}`); }; return { handle: _handleClick, }; }, }); class PluginNode extends HtmlNode { setHtml(rootEl: HTMLElement) { const vm = h(myHtmlNode, {}); vueRender(vm, rootEl); } }</description></item><item><title>clojure支持参数重载的宏</title><link>https://youkale.github.io/posts/make-clojure-overload-definline/</link><pubDate>Thu, 21 Oct 2021 12:32:29 +0800</pubDate><guid>https://youkale.github.io/posts/make-clojure-overload-definline/</guid><description> 问题 通过clojure.core/definline可以以方法的形态定义一个宏，但是definline这个宏却只支持固定的参数，在某些情况下需要支持不同参数的宏，从java的角度来说就是方法重载了。
支持重载的definline 大部分代码都是在definline的基础上魔改的。
(defmacro definline+ [name &amp;amp; decl] (let [body (map (fn [[args# expr#]] (let [f# (apply (eval (list `fn (list args# expr#))) args#)] `(~args# ~f#))) decl) alt-body (map (fn [[args# expr#]] `(~args# ~expr#)) decl)] `(do (defn ~name ~@body) (alter-meta! (var ~name) assoc :inline (fn ~name ~@alt-body)) (var ~name))))])))])) 使用 比如noop 方法，现在可以支持2、3个参数了。
(definline+ noop ([a b] (or ~a ~b)) ([a b c] (or ~a ~b ~c)))</description></item><item><title>当引入MQ后...</title><link>https://youkale.github.io/posts/after-import-mq/</link><pubDate>Thu, 16 Sep 2021 15:19:47 +0000</pubDate><guid>https://youkale.github.io/posts/after-import-mq/</guid><description>当引入MQ后，可能需要考虑这些 保证不丢失消息 生产者 ack, 集群内大部分或全部slave都获取到消息 消息发送失败重试次数 存储 MQ集群副本 消息保留时间 消息保留大小 消息定时清理 消费者 只有在消费完成后才提交业务 补偿 保存, 在消息写入队列后，同时写入一份到DB，并加入状态字段。 在消费者消费完成并改变状态。 启动定时任务Check失败数据，然后加载失败数据进行重新发送。 重发阀值，重试几次后，认为改消息无法消费,并记录 生产过慢 配置 消息大小 序列号方式 ACK模式,是否需要集群内所有slave全部确认 消费过慢 配置 序列化方式 MQ是否支持(Peer-to-Peer)，即每分区每消费者模式 其他 当前拆封消费者,需要依赖多个服务响应,导致相应时间过长。 代码是否有性能问题 幂等 这个一般是通过在业务层面保证，比如通过唯一id，判断数据是否重复。</description></item><item><title>如何提高golang的可读性</title><link>https://youkale.github.io/posts/%E6%8F%90%E9%AB%98golang%E7%9A%84%E5%8F%AF%E8%AF%BB%E6%80%A7/</link><pubDate>Sat, 30 Mar 2019 18:55:00 +0000</pubDate><guid>https://youkale.github.io/posts/%E6%8F%90%E9%AB%98golang%E7%9A%84%E5%8F%AF%E8%AF%BB%E6%80%A7/</guid><description>1. 尽早返回 反例:
//UserCtrl func UserInfo(userId string){ user.UserInfo(userId) .... .... //resp result ... } //UserService func UserInfo(userId string){ if len(userId) &amp;gt; 0 { //do query database ..... } } // repo func queryUserInfo(userId string){ if len(userId) &amp;gt; 0{ //select * from user where user_id = ? } } 从这个例子来看，在service层和数据库查询，我们都进行了userId的判断. 因为当我们经常会忘记，我们是否在上一层入参的时候进行了userId为空的判断. 为了避免空指针，我们不得已一层层进行判断.
假如我们尽早地返回，那么就可以避免后续的层层判空
推荐写法:
//userCtrl func UserInfo(userId string){ if len(userId) == 0 { //resp some error } user.UserInfo(userId) } 2. 写好分支语句 反例:</description></item><item><title>通过Connector/J实现数据库读写分离</title><link>https://youkale.github.io/posts/mysql-read-and-write-separation/</link><pubDate>Fri, 01 Mar 2019 10:40:00 +0000</pubDate><guid>https://youkale.github.io/posts/mysql-read-and-write-separation/</guid><description>前言 在公司的一些业务中，不管什么分布式应用还是单机应用，不可否认CURD是日常工作中最常接触的，那么数据库的性能问题，可能就关系到你整个应用的性能。随着公司的成长，数据两的增大，很多公司为了保证数据的安全、可用，一般都会通过binlog加入slave服务器对master进行一个备份, 但是在实际应用中，很多人都把slave仅仅当作一个备份，最多的就是dba同学可能在slave上面查点数据, 而我们的应用还只是对主库的一个读写。那么我们怎么样才能把slave利用起来呢？ 很多同学可能回想到在应用代码中配置两个数据源,针对select语句走从库，修改操作走主库。用过sharding-jdbc的也许就会想到用他的master-slave模式，这些都是可以实现读写分离。
Connector/J 前面卖了个关子，那么下面我就来补充一个使用原生Mysql驱动如何简单实现读写分离:
jdbc:mysql:replication://[master host][:port],[slave host 1][:port][,[slave host 2][:port]]...[/[database]][?propertyName1=propertyValue1[&amp;amp;propertyName2=propertyValue2]...] 是不是看了这个URI立刻就明白了？ mysql驱动可以直接通过配置replication来实现读写分离. 当用多个slave,会自动在slaves中根据你的策略进行LB,内置的策略有random(随机),bestResponseTime(最快响应),sequential(顺序),如果这些都不能满足你的需求,你还可以自己实现BalanceStrategy接口自定义一个。不用改一行业务代码，通过修改一个jdbc连接字符串就能实现读写分离，还有什么比这个更爽的吗？</description></item><item><title>k8s记录</title><link>https://youkale.github.io/posts/k8s%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 18 Feb 2019 15:55:36 +0000</pubDate><guid>https://youkale.github.io/posts/k8s%E8%AE%B0%E5%BD%95/</guid><description>用rancher配置k8s环境 删除已经安装的docker yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo yum install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-selinux-17.03.2.ce-1.el7.centos.noarch.rpm yum install docker-ce-17.03.2.ce-1.el7.centos 配置 rancher docker pull rancher/server:v1.6.14 docker run -d --name rancher-mysql -p 3306:3306 -v /opt/rancher/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=rancher_mysql -d percona:5.7.22-stretch --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci docker run -it --rm --link rancher-mysql create database rancher ; GRANT ALL ON *.</description></item><item><title>linux监控相关</title><link>https://youkale.github.io/posts/linux%E7%9B%91%E6%8E%A7%E7%9B%B8%E5%85%B3/</link><pubDate>Wed, 13 Feb 2019 15:15:50 +0000</pubDate><guid>https://youkale.github.io/posts/linux%E7%9B%91%E6%8E%A7%E7%9B%B8%E5%85%B3/</guid><description> 端口连接情况 lsof -i :6379 网卡速率 sar -n DEV 1 IO监控 iostat -x -t 1 综合监控 dstat -cdlmnpsy</description></item><item><title>数据库杂记</title><link>https://youkale.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%82%E8%AE%B0/</link><pubDate>Wed, 13 Feb 2019 15:11:45 +0000</pubDate><guid>https://youkale.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%82%E8%AE%B0/</guid><description>Postgres导出 \o 文件名 select * from table ; \o
\copy (select parent_id+123456789,count(*) cnt from user_relations where user_id between 24304192 and 24368430 and parent_id != 1 group by parent_id order by cnt desc) To &amp;lsquo;/tmp/sf.csv&amp;rsquo; With CSV
Mysql初始化 初始化 mysqld --user=mysql --datadir=/datas/mysql --initialize-insecure 重设密码 service mysql stop [mysqld] skip-grant-tables update user set authentication_string = password('Aa12345678') where user = 'root'; flush privileges; set global validate_password_policy=0; ALTER USER 'root'@'localhost' identified by 'Aa12345678' ; GRANT ALL PRIVILEGES ON *.</description></item><item><title>es集群配置</title><link>https://youkale.github.io/posts/es%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/</link><pubDate>Wed, 13 Feb 2019 15:04:44 +0000</pubDate><guid>https://youkale.github.io/posts/es%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/</guid><description>服务器部署说明 Linux 安装wget yum install wget -y 修改内核最大map数量并生效 echo 'vm.max_map_count = 262144' &amp;gt;&amp;gt; /etc/sysctl.conf &amp;amp;&amp;amp; sysctl -p 新增用户es useradd es -d /opt/es 设置文件打开数量 编辑 vi /etc/security/limits.conf 增加 es - nofile 65536 elasticsearch 集群部署 查看各个节点ip,确保能相互ping通: 如:
10.20.250.80 10.20.250.81 10.20.250.82 各个节点切换用户,下载elasticsearch,解压
su - es wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.3.1.tar.gz tar -zxv -f elasticsearch-6.3.1.tar.gz ln -s elasticsearch-6.3.1 elasticsearch 编辑节点1配置文件 elasticsearch/config/elasticsearch.yml
cluster.name: erp-dfs node.name: ${HOSTNAME} #path.data: /esdata/data #path.logs: /esdata/logs network.host: 10.20.250.80 http.port: 9200 transport.tcp.port: 9300 bootstrap.system_call_filter: false xpack.</description></item><item><title>kafka集群配置</title><link>https://youkale.github.io/posts/kafka%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/</link><pubDate>Wed, 13 Feb 2019 15:01:13 +0000</pubDate><guid>https://youkale.github.io/posts/kafka%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/</guid><description>Kafka集群配置 kafka集群需要使用到zookeeper,需要在配置kafka之前配置zookeeper 本集群里使用的主机ip
节点1: 10.20.250.80 节点2: 10.20.250.81 节点3: 10.20.250.83 相关路径
主程序: /data/kafka kafka配置: /data/kafka/server.properties kafka数据: /data/kafka/kafkadata zookeeper配置: /data/kafka/zookeeper.properties zookeeper数据: /data/kafka/zkdata 首先下载kafka,部署中使用的版本为 kafka_2.11-0.10.2.1.tgz
cd /data/ tar -zxv -f kafka_2.11-0.10.2.1.tgz ln -s kafka_2.11-0.10.2.1.tgz kafka zookeeper 集群配置 每个节点对应开放的端口有 2181 ```` 2888 ``` 3888
首先确认zookeeper的数据日志目录,比如本例中使用的 /data/kafka/zkdata #在3个节点上分别执行,创建目录 mkdir -p /data/kafka/zkdata 生成myid 节点1~$ echo 1 &amp;gt; /data/kafka/zkdata/myid #10.20.250.80 节点2~$ echo 2 &amp;gt; /data/kafka/zkdata/myid #10.20.250.81 节点3~$ echo 3 &amp;gt; /data/kafka/zkdata/myid #10.20.250.83 生成配置文件 /data/kafka/zookeeper.properties tickTime=2000 initLimit=5 syncLimit=2 dataDir=/data/kafka/zkdata dataLogDir=/data/kafka/zkdata clientPort=2181 server.</description></item><item><title>linux常用命令命令</title><link>https://youkale.github.io/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Wed, 13 Feb 2019 14:50:27 +0000</pubDate><guid>https://youkale.github.io/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description> 制作linux usb启动盘 格式化u盘 mkfs.vfat -F 32 -n USB /dev/sdb1 安装syslinux,mtools apt-get install syslinux mtools 安装linux引导 /usr/bin/syslinux /dev/sdb1 写入mbr cat /usr/lib/syslinux/mbr/mbr.bin &amp;gt; /dev/sdb 配置重命名 mv ioslinux.cfg syslinux.cfg 安装镜像 //TODO
chroot时绑定 mount --bind /proc /mnt/proc mount --bind /run /mnt/run mount --bind /dev /mnt/dev mount --bind /sys /mnt/sys 获取文件魔数(判断文件类型) xxd file.png | head -n 1 | awk '{print $2$3}'</description></item><item><title>kafka常用命令记录</title><link>https://youkale.github.io/posts/kafka%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</link><pubDate>Wed, 13 Feb 2019 14:28:42 +0000</pubDate><guid>https://youkale.github.io/posts/kafka%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</guid><description>kafka常用命令记录 消费测试 kafka-console-consumer.bat --bootstrap-server 172.20.2.95:9092 --topic xxx --from-beginning 查看消费者 kafka-consumer-groups.sh --bootstrap-server 172.20.2.95:9092 --list kafka-consumer-groups.sh --zookeeper 172.20.2.95:2181 --list 查看新加入的消费者 kafka-consumer-groups.sh --new-consumer --bootstrap-server 172.20.2.95:9092 --list 修改分区 kafka-topics.sh --zookeeper 10.20.247.104:2181,10.20.247.105:2181,10.20.247.106:2181 --alter --topic yugong-dfs_db-ta_documents --partitions 20 查看分区 kafka-topics.sh --zookeeper 10.20.247.104:2181,10.20.247.105:2181,10.20.247.106:2181 --topic yugong-dfs --describe 生产者压测 kafka-producer-perf-test.sh --topic test_produce --num-records 100000000 --record-size 1000 --throughput 200000 --producer-props bootstrap.servers=10.20.247.104:9092,10.20.247.105:9092,10.20.247.106:9092 消费者压测 kafka-consumer-perf-test.sh --zookeeper localhost:2181 --topic test_perf --fetch-size 1048576 --messages 1000000 --threads 1 增加副本 kafka-reassign-partitions.sh --zookeeper 10.20.247.104:2181,10.20.247.105:2181,10.20.247.106:2181 --reassignment-json-file replicas.json --execute 验证副本 kafka-reassign-partitions.</description></item><item><title>由js精度缺失引发的问题及处理方法</title><link>https://youkale.github.io/posts/%E7%94%B1js%E7%B2%BE%E5%BA%A6%E7%BC%BA%E5%A4%B1%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</link><pubDate>Sun, 18 Nov 2018 12:10:54 +0000</pubDate><guid>https://youkale.github.io/posts/%E7%94%B1js%E7%B2%BE%E5%BA%A6%E7%BC%BA%E5%A4%B1%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</guid><description>问题场景 在使用java的Long类型过程中,当这个Long类型数值超过 1^0+1^1+1^2+...1^58的范围后就会引发精度丢失, 详见JS[IEEE754规范](https://en.wikipedia.org/wiki/IEEE_754) 常见的现象就是比如:1000967854800048128,通过js转换成Number类型成为了:1000967854800048100, 由此会引发一系列问题,比如当年著名的爱国者导弹. 因为精度缺失造成问题,大多数情况发生在前后端交互过程中,那么下面就分别说说处理方法 普通场景的处理方法 简单的处理方法，jackson,gson等json工具包已经包含了Long类型处理方法了,基本上都是转String.
gson处理方法 GsonBuilder builder = new GsonBuilder(); //默认将所有的Long转换成String builder.setLongSerializationPolicy(LongSerializationPolicy.STRING); jackson处理方法 ObjectMapper objectMapper = new ObjectMapper(); SimpleModule module = new SimpleModule(); module.addSerializer(Long.class, ToStringSerializer.instance); module.addSerializer(Long.TYPE, ToStringSerializer.instance); 高级场景处理 为了避免将其他无需转换成String的Long类型转换,这里提供一个高级的用法， 思路很简单就是定义一个Id类型,通过实现Id类型的序列化和反序列化功能即可进行实现. 下面就用Gson和jackson来演示
核心代码 //Gson GsonBuilder builder = new GsonBuilder(); builder.registerTypeAdapter(Id.class, (JsonSerializer&amp;lt;Id&amp;gt;) (src, typeOfSrc, context) -&amp;gt; new JsonPrimitive(src.getVal())); builder.registerTypeAdapter(Id.class, (JsonDeserializer&amp;lt;Id&amp;gt;) (json, typeOfT, context) -&amp;gt; new Id(json.getAsLong())); Gson gson = builder.create(); User user = new User(); user.setUserId(new Id(11111L)); user.</description></item><item><title>Gitlab和Docker实践持续集成</title><link>https://youkale.github.io/posts/gitlab%E5%92%8Cdocker%E5%AE%9E%E8%B7%B5%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</link><pubDate>Wed, 29 Aug 2018 10:45:37 +0000</pubDate><guid>https://youkale.github.io/posts/gitlab%E5%92%8Cdocker%E5%AE%9E%E8%B7%B5%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</guid><description>前言 本文面向那些每次发包,都是本地构建,通过奇慢无比的网络进行上传,一旦打包出错(or 没有fix bug)，还需要重新上传,无穷无尽的任务还在等着,而此刻网络成了瓶颈。又或者此刻测试人员正在测试,而你停了服务,造成测试工作无法进行,此刻的你已经是万人瞩目了,测试、项目经理已经磨刀霍霍了.就问你慌不慌?
打包 上面说的情况其实是程序发版,说到发版目前各个系统程序交付形式有大概分为这些: windows常见的zip,rar,msi等; Linux常见的rpm,deb等; mac常见的dmg等;java语言的有jar,war包等; 然而多种的打包形式,依赖的环境不一样,每种包也只能是在特定的环境下才能使用,这其实对运维也是一种挑战. 那么有没有一种包是各个平台都可以用，而且不用去关心目标机器环境的呢? 答案就是: docker,下面我们就结合docker,进行自动化打包, 缩短各个职能间沟通的成本.
Docker 玩过docker的人都知道,这玩意真心好,都不用为环境操心了, 运维也只需要关心namespace和cgroups就好了，不用在去管什么rpm包,deb包,tar.gz扽等了。
使用工具 Gitlab: 代码仓库, 构建工具(pipeline) Nexus: maven仓库, docker register (新版Gitlab已经包含Registery) Docker: 容器 Webhook: 自己写的 [Github] (https://github.com/youkale/gitlab-webhook) 基本流程 3 +-----------------------------+ | | | | +---------+ 1 +------v-------+ +--------+------+ | | | | 2 | | | Coder +---------&amp;gt; Gitlab +------------&amp;gt; Gitlab Runner | | | | | | | +---------+ +---^----+-----+ +--------+------+ | | | | | | | | +-----------------+ | 4 | | | | | | | | Docker Registry &amp;lt;------+ | | | | | 5| +-------^---------+ 7| | | | | | 6 | | +-------+---------+ | | | | | +--&amp;gt; Target Server | | | | | +-------+---------+ | | +---------------+ 1.</description></item><item><title>IntelliJ IDEA的Tips贼好用</title><link>https://youkale.github.io/posts/intellij-idea%E7%9A%84tips%E8%B4%BC%E5%A5%BD%E7%94%A8/</link><pubDate>Sun, 26 Aug 2018 13:54:43 +0000</pubDate><guid>https://youkale.github.io/posts/intellij-idea%E7%9A%84tips%E8%B4%BC%E5%A5%BD%E7%94%A8/</guid><description>废话 IntelliJ IDEA功能强大,用过得到的朋友也都知道,可能你认为一个新的工具同样的也会带来相应的学习成本。其实没有想象的那么复杂，只要关心idea给你提示的黄色警告即可， 然后用 alt + enter 使用更好的方式重构即可. 本文没有上面实质内容，只是在安利大家用IDEA, 把代码写好，少加班
Lambda 转换前
ExecutorService executorService = Executors.newCachedThreadPool(); executorService.submit(new Runnable() { @Override public void run() { System.out.println(&amp;quot;xxx&amp;quot;); } }); 转换后
public void runJob() { ExecutorService executorService = Executors.newCachedThreadPool(); executorService.submit(() -&amp;gt; System.out.println(&amp;quot;xxx&amp;quot;)); } Stream 转换前
public boolean contains(List&amp;lt;Person&amp;gt; ps) { return ps.stream().filter(s -&amp;gt; s.getName().equals(&amp;quot;youkale&amp;quot;)).findAny().isPresent(); } 转换后
public boolean contains(List&amp;lt;Person&amp;gt; ps) { return ps.stream().anyMatch(s -&amp;gt; s.getName().equals(&amp;quot;youkale&amp;quot;)); } 异常 转换前
try{ .... }catch (IOException ioe){ }catch (FileNotFoundException fe){ } 转换后</description></item><item><title>vim 学习笔记(持续更新)</title><link>https://youkale.github.io/posts/vim-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><pubDate>Fri, 24 Aug 2018 10:37:12 +0000</pubDate><guid>https://youkale.github.io/posts/vim-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid><description> Vim学习笔记 几乎每次管理服务器的时候或多或少得接触到vim，一直都觉得他很复杂，只会简单的打开文件，修改，保存, 终于在最近项目不太忙的时候，沉寂心来认真学习了一把，收益还是蛮大的，出乎意料得高效. 其实认真学起来vim不是想象中的那么难.只是要多练习就好. 于是乎我把学习的笔记整理了一下，发出来，以后有学到新姿势也更新上来.
操作说明约定 &amp;lt;num&amp;gt; : 表示数字 &amp;lt;char&amp;gt; : 表示字符 &amp;lt;C&amp;gt; : 表示control键 {} : 表示可选择 命令行 set nu: 显示行号 set relativenumber: 显示相对行号 单词操作 w: 下一个单词首部 b: 上一个单词首部 e: 下一个单词尾部 光标移动 h: 左下上右 ^: 光标移动到行首非空白字符 0: 光标移动到行首 $: 光标移动到行尾 g: 光标移动到行尾非空白字符处 &amp;lt;: x次 左下上右移动 &amp;lt;: 到x行首 g: 到第一行 G: 到行尾 ): 下一个句子 (: 上一个句子 M: 光标移动到屏幕中央 H: 光标移动到屏幕上方 L: 光标移动到屏幕下方 z: 当前行移动到屏幕中央 z: 当前行移动到屏幕上方 z: 当前行移动到屏幕下方 f: 光标移动到下一个&amp;lt;char&amp;gt;处 &amp;lt;: 光标移动到第&amp;lt;num&amp;gt;个字符 t: 光标移动到下一个&amp;lt;char&amp;gt;左侧 &amp;lt;: 光标移动到第&amp;lt;num&amp;gt;个&amp;lt;char&amp;gt;左侧 %: 切换到下一个 {,[,( 处 {: 向{下，上}查找当前光标单词 行为 r: 替换当前字符 x: 删除当前光标字符 s: 类似x,进入编辑模式 c: 剪切操作，并进入编辑模式 v: 行内选择 d: 删除操作 y: 复制 p: 粘帖 g: 搜索(不一定正确) 组合动作 行为 + 次数(可以省略) + 范围描述 + 文本对象 行为: d,c,y,v等 范围描述：i,a,t,f 文本对象: p: 段落 s: 句子 w: 单词 t: tag 举例: ve 选择到单词结尾 vf2: 当前位置查找到第二个&amp;quot;:&amp;quot; cw 剪切当前单词 dt: 从当前位置删除到&amp;quot;:&amp;quot; gd 跳转掉变量定义 gUe 当前位置到单词结尾转化为小写,同样适用于w,b gue 当前位置到单词结尾转化为小写 gUU 当前行转换为大写 guu 当前行转换为小写 宏 录制: 使用qa,定义名字为a的宏(存放的寄存器)，接下来可以录入一些操作，录入完成后，按q结束 回放: 1@a ,表示回放1次, @@ 回放最新录制的宏 窗口操作 :split: 水平分割 :vsplit: 垂直分割 &amp;lt;C-w&amp;gt;{hjkl}: 窗口切换 &amp;lt;C-w&amp;gt;{-,+,_}: 缩小,放大,最大</description></item><item><title>重谈redis分布式锁</title><link>https://youkale.github.io/posts/redis-distributed-lock/</link><pubDate>Sun, 12 Aug 2018 16:58:39 +0000</pubDate><guid>https://youkale.github.io/posts/redis-distributed-lock/</guid><description>前言 Redis分布式锁其实网上已经一大把了，我写这篇博客的目的是想发表下自己的浅见。
我们知道在单进程中，通过语言内置的锁可以保证数据的一致性，随着软件的不断扩大，很多应用已经是多进程的方式部署,那么为了保证数据的一致性,我们需要一个分布式锁。标题说的是Redis分布式锁，那么我下面主要讲的rendis锁，而且不会涉及到redis单点故障的问题。
常见的分布锁 搜索一下常见的分布式锁说的都是通过redis和zookeeper来实现。
redis
setnx 通过设置一个共有的key，而且通过设置过期时间来避免死锁
zk
通过设置一个共有的节点,通过zk的watch,观察节点的变化进行通知
锁的需求 独占: 一个时间点只能一个线程访问
可重入: 同一个线程只要当前持有锁，可以重复进入
避免死锁: 多个线程访问不会出现死锁的情况
锁释放: 进程故障能自动释放锁，只有持有锁的进程能释放锁
尝试自己实现一个 实现 copy from importnew Redis 分布式锁的正确实现方式（ Java 版 ）
public class RedisTool { private static final String LOCK_SUCCESS = &amp;#34;OK&amp;#34;; private static final String SET_IF_NOT_EXIST = &amp;#34;NX&amp;#34;; private static final String SET_WITH_EXPIRE_TIME = &amp;#34;PX&amp;#34;; public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) { String result = jedis.</description></item><item><title>About</title><link>https://youkale.github.io/about/</link><pubDate>Sun, 12 Aug 2018 11:34:29 +0000</pubDate><guid>https://youkale.github.io/about/</guid><description/></item><item><title>url.Values转换struct</title><link>https://youkale.github.io/posts/url-value-cast-struct/</link><pubDate>Sat, 13 Jan 2018 15:36:00 +0000</pubDate><guid>https://youkale.github.io/posts/url-value-cast-struct/</guid><description>前言 大家在写golang http服务的时候或许会碰到Request中url.Values转换成struct的需要。
思路 翻开net.url查看url.Values的定义
type Values map[string][]string 那么我是不是可以通过遍历struct的Field获取对应的数据类型，以及通过tag来从url.Values中获取对应的参数？ 答案是可以的，那么我们就开动吧。
先来定义一个struct,还有一个叫param的tag。 type User struct { UserId int `param:&amp;#34;user_id,100&amp;#34; } struct说明 字段名: UserId url.Values中的字段名: user_id 默认值: 100 实现 typ := val.Type() for i := 0; i &amp;lt; val.NumField(); i++ { kt := typ.Field(i) //获取字段类型 tag := kt.Tag.Get(&amp;#34;param&amp;#34;) //获取tag sv := val.Field(i) //获取字段值 uv := getVal(values, tag) //获取默认值 switch sv.Kind() { case reflect.String: .... case reflect.Bool: .... } } 性能测试 goos: linux goarch: amd64 pkg: github.</description></item><item><title>clojure.xml忽略DTD验证</title><link>https://youkale.github.io/posts/clojure.xml%E5%BF%BD%E7%95%A5dtd%E9%AA%8C%E8%AF%81/</link><pubDate>Sun, 21 May 2017 12:32:29 +0800</pubDate><guid>https://youkale.github.io/posts/clojure.xml%E5%BF%BD%E7%95%A5dtd%E9%AA%8C%E8%AF%81/</guid><description>问题 在通过clojure生成mybatis mapper文件的过程中，发现启动过程缓慢，原因是会验证xml的schema，因此解决方法就是屏蔽掉DTD的验证
clojure.xml API没有DTD写入解决: (defn emit-xml &amp;#34;Prints the given Element tree as XML text to stream. Options: :encoding &amp;lt;str&amp;gt; Character encoding to use&amp;#34; [e &amp;amp; {:as opts}] (let [stream (StringWriter.) ^XMLStreamWriter writer (-&amp;gt; (XMLOutputFactory/newInstance) (.createXMLStreamWriter stream))] (when (instance? OutputStreamWriter stream) (check-stream-encoding stream (or (:encoding opts) &amp;#34;UTF-8&amp;#34;))) (.writeStartDocument writer (or (:encoding opts) &amp;#34;UTF-8&amp;#34;) &amp;#34;1.0&amp;#34;) (.writeDTD writer &amp;#34;&amp;lt;!DOCTYPE mapper PUBLIC \&amp;#34;-//mybatis.org//DTD Mapper 3.0//EN\&amp;#34; \&amp;#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\&amp;#34;&amp;gt;&amp;#34;) (doseq [event (flatten-elements [e])] (emit-event event writer)) (.</description></item><item><title>数组内存分配</title><link>https://youkale.github.io/posts/array-memory-allocation/</link><pubDate>Sat, 20 May 2017 18:55:00 +0000</pubDate><guid>https://youkale.github.io/posts/array-memory-allocation/</guid><description>废话 今天是所谓的520，高富帅此刻正在xxx，我等屌丝在写博客，悲哀呀。。
如题 //定义一个容量为5,长度为4的数组 slice := [5]int{10, 20, 30, 40} //cap = 5 - 1 //len = 3 -1 //一个新的切片 newSlice := slice[1:3] //增加两个元素 //这些操作其实是在原有的数组上进行操作 //因为cap都在这个原有的数组范围内 newSlice = append(newSlice, 50, 60) fmt.Printf(&amp;#34;slice cap %d len %d, newSlice cap %d len %d \n&amp;#34;, cap(slice), len(slice), cap(newSlice), len(newSlice)) //遍历并打印出指针地址 for i1, v1 := range slice { fmt.Println(i1, v1, &amp;amp;slice[i1]) } fmt.Printf(&amp;#34;slice cap %d len %d, newSlice cap %d len %d \n&amp;#34;, cap(slice), len(slice), cap(newSlice), len(newSlice)) //遍历并打印出指针地址 for i2, v2 := range newSlice { fmt.</description></item><item><title>Jetty嵌入开发路径问题</title><link>https://youkale.github.io/posts/jetty-embedded-development-path-problem/</link><pubDate>Fri, 28 Oct 2016 13:32:00 +0000</pubDate><guid>https://youkale.github.io/posts/jetty-embedded-development-path-problem/</guid><description>我都知道在使用jetty在嵌入开发的时候使用ContextHandler，通过 setContextPath设置访问路径，通过setHandler来使用自定义的handler.最终设置到Server中，服务就可以跑起来了。
官方的栗子 Server server = new Server(8080); ContextHandler context = new ContextHandler(&amp;#34;/&amp;#34;); context.setContextPath(&amp;#34;/&amp;#34;); context.setHandler(new HelloHandler(&amp;#34;Root Hello&amp;#34;)); ContextHandler contextFR = new ContextHandler(&amp;#34;/fr&amp;#34;); contextFR.setHandler(new HelloHandler(&amp;#34;Bonjoir&amp;#34;)); ContextHandler contextIT = new ContextHandler(&amp;#34;/it&amp;#34;); contextIT.setHandler(new HelloHandler(&amp;#34;Bongiorno&amp;#34;)); ContextHandler contextV = new ContextHandler(&amp;#34;/&amp;#34;); contextV.setVirtualHosts(new String[] { &amp;#34;127.0.0.2&amp;#34; }); contextV.setHandler(new HelloHandler(&amp;#34;Virtual Hello&amp;#34;)); contextV.setInitParameter(&amp;#34;dirAllowed&amp;#34;, &amp;#34;false&amp;#34;); ContextHandlerCollection contexts = new ContextHandlerCollection(); contexts.setHandlers(new Handler[] { context, contextFR, contextIT, contextV }); server.setHandler(contexts); server.start(); server.join(); 开始 细心的朋友可能在使用中发现，明明我定义的路径是/user ,但是在访问的时候却进行了一次302跳转，然后最终变成了/user/ ,经过调试发现,在ContextHandler这个类中发现下面这个有趣的问题
// Are we not the root context?</description></item><item><title>openwrt简单的dns方案</title><link>https://youkale.github.io/posts/openwrt-dns/</link><pubDate>Mon, 03 Oct 2016 14:05:00 +0000</pubDate><guid>https://youkale.github.io/posts/openwrt-dns/</guid><description>准备 环境 NETGEAR WNDR3700v4 OpenWrt Chaos Calmer 15.05.1 / LuCI 15.05-149-g0d8bbd2 Release (git-15.363.78009-956be55) 准备软件 dnscrypt-proxy 安装 dnscrypt-proxy $ opkg update $ opkg install dnscrypt-proxy 简单不？
配置/etc/config/dnscrypt-proxy config dnscrypt-proxy option address &amp;#39;127.0.0.1&amp;#39; option port &amp;#39;5553&amp;#39; # option resolver &amp;#39;opendns&amp;#39; option resolvers_list &amp;#39;/usr/share/dnscrypt-proxy/dnscrypt-resolvers.csv&amp;#39; 开机运行&amp;amp;启动
/etc/init.d/dnscrypt-proxy enable /etc/init.d/dnscrypt-proxy start 一般openwrt 会使用dnsmasq作为dns和dhcp服务，所以这里也得该 编辑/etc/config/dhcp
config dnsmasq option domainneeded &amp;#39;1&amp;#39; option boguspriv &amp;#39;1&amp;#39; option filterwin2k &amp;#39;1&amp;#39; option localise_queries &amp;#39;1&amp;#39; option rebind_protection &amp;#39;1&amp;#39; option rebind_localhost &amp;#39;1&amp;#39; option local &amp;#39;/lan/&amp;#39; option domain &amp;#39;lan&amp;#39; option expandhosts &amp;#39;1&amp;#39; option nonegcache &amp;#39;0&amp;#39; option authoritative &amp;#39;1&amp;#39; option readethers &amp;#39;1&amp;#39; option leasefile &amp;#39;/tmp/dhcp.</description></item><item><title>微商锁粉重构思路</title><link>https://youkale.github.io/posts/fans-mall-user-relation/</link><pubDate>Fri, 12 Aug 2016 21:52:36 +0000</pubDate><guid>https://youkale.github.io/posts/fans-mall-user-relation/</guid><description> 项目背景 ​ 通过分享链接到朋友圈、微信群进行锁粉，当被锁粉对象消费后，会通过比例返佣给分享链接的用户。
问题描述 ​ 点击链接进入的用户，因为业务处理过长，出现响应超时情况，导致系统吞吐量过低、甚至出现点击链接后用户锁粉失败的情况。
业务分析 调用步骤:
需要获取微信用户信息。 计算上级用户的粉丝数量。 同时统计当天新增用户。 微信头像会过期，需要将图片同步到对象存储。 &amp;hellip;. 非业务分析 高性能 ​ 按照目前用户新增的速度来看，每秒TPS大约在15。
​ 用户获取信息相关QPS大约为500。
高可用 ​ 用户在分享链接时候不允许出现点击锁定粉失败。
​ 同时在运营后台需要得知当天新增用户。
可扩展性 支持水平扩展。
评估结果 功能性：解决业务发展带来的系统耦合、迭代缓慢问题。
非功能性：要解决系统新增用户的高可用、查询用户的高性能。
通过经验值计算高峰时期= 平时峰值 * 4，来计算新增与查询用户性能指标:
新增用户(TPS) * 4 = 60 ， 采用异步形式MQ(Kafka,rabbitMQ)/Redis(pub/sub,lpush/rpop)/JVM+Mysql进行处理。 查询用户(QPS) * 4 = 2000，qps不高，可以通过通过水平部署2台避免单点。 技术实现考量 异步
Kafka集群，支持高可用: 生产者：可用通过ack参数来确定消息推送集群各个broker中的副本。每个topic可以配置副本数量。 消费者：可以通过扩展分区进行多消费者进行消费，并且可以在在业务完成后提交事物。同样的消息即使消费后，也可以通过修改group-id进行重复消费。 Redis哨兵，支持高可用 JVM队列，不支持高可用 保障100%不丢消息：
定时轮询：数据写入MQ后同时写入Mysql，并加入状态字段。 消费确认：数据消费后，提交事物，同时更新数据库中的状态。</description></item><item><title>如何优雅的读取流</title><link>https://youkale.github.io/posts/how-to-read-the-stream-gracefully/</link><pubDate>Wed, 22 Jun 2016 23:50:00 +0000</pubDate><guid>https://youkale.github.io/posts/how-to-read-the-stream-gracefully/</guid><description>Java中关于InputStream读取很多人立马就想到下面的写法:
InputStream inputStream = null; InputStreamReader reader = null; BufferedReader bufferedReader = null; try { inputStream = new FileInputStream(&amp;#34;/home/0x1024/1024.txt&amp;#34;); reader = new InputStreamReader(inputStream); bufferedReader = new BufferedReader(reader); String temp; StringBuilder sb = new StringBuilder(); while (null != (temp = bufferedReader.readLine())) { sb.append(temp); } System.out.print(sb.toString()); } catch (IOException e) { e.printStackTrace(); } finally { if (null != inputStream){ inputStream.close(); } if (null != reader){ reader.close(); } if (null != bufferedReader){ bufferedReader.close(); } } 下面这几个类都实现了Closeable,所以读取完毕后都需要关闭。</description></item><item><title>Ngrok 编译的坑</title><link>https://youkale.github.io/posts/ngrok-compile-problem/</link><pubDate>Wed, 01 Jun 2016 17:57:00 +0000</pubDate><guid>https://youkale.github.io/posts/ngrok-compile-problem/</guid><description>ngrok 是用go语言实现的，编译过程碰到不少坑 主要碰到的坑就是依赖错误，以及依赖的包被伟大的GFW给挡住了。 最好是用天朝外的VPS make release-server release-client
修改日志src/ngrok/log/logger.go中的import部分改成
import ( log &amp;#34;github.com/alecthomas/log4go&amp;#34; &amp;#34;fmt&amp;#34; ) 其他的跟网上的差不多了。 下面就把依赖好的包打包发上来，以及编译的方法给大家说下： 这个包是已经包含好了依赖，拿到包后，确认你的环境，如果你要编译客户端需要go 1.6 否则编译会通不过
安装依赖 sudo apt-get install build-essential golang mercurial git 解压 tar -zxv -f ngrok.pkg.tar.gz 生成证书 openssl genrsa -out base.key 2048 openssl req -new -x509 -nodes -key base.key -days 10000 -subj &amp;#34;/CN=ngrok.youkele.com&amp;#34; -out base.pem openssl genrsa -out server.key 2048 openssl req -new -key server.key -subj &amp;#34;/CN=ngrok.youkele.com&amp;#34; -out server.csr openssl x509 -req -in server.</description></item><item><title>我拿什么保护你，我的隐私(2)</title><link>https://youkale.github.io/posts/how-can-protect-personal-privacy-2/</link><pubDate>Wed, 03 Feb 2016 15:19:00 +0000</pubDate><guid>https://youkale.github.io/posts/how-can-protect-personal-privacy-2/</guid><description>0x01 上一篇已经说过用户名和密码的隐私保护了，那么今天我就来说说关于手机中常见的隐私问题
0x02 android 经历几代的发展，我这屌丝也是经历了好几个版本 defy 2.x 时代 nexus 5 从4.x 到 5.x 到最新的6.x 总的来说在6.x 之前 android 的app权限是：app想要什么就给什么 也就是说：这app要干什么坏事完全是凭程序员的节操. 6.0之后的现在android也有了ios的类似的应用程序权限管理的功能，可以通过操纵系统来控制程序员的节操了。如果你的手机是亲儿子，那么建议你赶紧update吧！
0x03 iOS在隐私方面做的比android好多了，不过也只限于对app权限控制，记得我基友好像有说过iOS可以随机化Mac地址，但是我好像木有发现这功能.
0x04 现在的wifi已经成为人们生活必备品了，那么接入公共wifi发生了什么呢？
获取了你机器的名称. 获取了你无线模块的物理地址. 你所有的访问的非加密的连接都被人知道了. 你的位置被人知道了. 可以劫持你的某些请求. 那么别人知道这些信息能干嘛呢？ 先看看这些“免费午餐”的盈利方式：
定点投放广告 要么就是诱导注册页面 要么就是钓鱼Wi-Fi.（就是盗取敏感信息） 0x05 好了，说了那么多公公共Wi-Fi的问题，怎么防？
当然就是尽量不用 公共Wi-Fi 全程加密 使用一些隐私保护工具 ，有简单的童鞋快快推荐（之前问想做一个android Wi-Fi连接隐私化app，可是我这种行动力-5的渣渣一直没把界面画好，于是就一直拖拖拖&amp;hellip;.） 0x05 免费的东西虽然好，但是看你能不能承担因此造成的问题咯！
还有什么好的招，欢迎大家来交流哦！ 有什么不对的地方欢迎指出哦！</description></item><item><title>我拿什么保护你，我的隐私(1)</title><link>https://youkale.github.io/posts/how-can-protect-personal-privacy-1/</link><pubDate>Fri, 01 Jan 2016 15:19:00 +0000</pubDate><guid>https://youkale.github.io/posts/how-can-protect-personal-privacy-1/</guid><description>0x01 本文主要是给安全意识薄弱的盆友们看的，黑阔请绕行.要是有说得不对的地方，砖头可要轻点扔哦！
0x02 今天的主题就是：如何注册用户 那么我们看看一个简单的日常的行为，到底会有一些什么隐患。
撞库 这什么鬼？不说好的注册用户么？别急先让我举个栗子：比如我在163.com注册了一个用户miaolegemi，密码19901010，我又在一个某小电影的网站注册了一个帐号密码一样的帐号.有一天你的小电影网站被黑阔(黑阔不一定等于hacker)入侵了，那么我的帐号密码被黑阔知道了，黑阔就会拿我这些帐号密码到个各大网站去试试，看能不能登陆，假如刚好跟我的appleid一样，那就可以锁定我手机或者看我相册羞羞的照片，当然你可能会说：还好我的帐号密码跟appleid不一样，只是跟支付宝一样，那么我就恭喜下你咯！
好！大致说完了撞库，应该都知道密码的重要性了，好那么我们开始注册，打开小电影网站abc.xxx
用户名：zhangshan 密码：zhangshan19901010¥&amp;amp;@ 大家觉得这个密码怎么样？ 够复杂的吧？嘿嘿嘿！ 其实呢这个密码有个很容易被忽视的问题，既然访问的是小电影网站，那么想的匿名，而这里的用户名和密码中暴露了我的姓名及生日信息，然后我刚好完善了个人信息，增加了手机号码，说不定哪天接到这样的电话：张先生你好，今天是你生日，有人给你寄了xxx礼物，请汇款到xxx上哦！
0x03 擦，我上个网我容易么？好可怕
如果你能坚持看到这里，那么我觉得你已经在想：我如何设置我的帐号密码呢？
也有盆友可能会问：APP要用手机注册怎么办？ 这个确实也是一个头疼的问题，特别是那种除了手机其他方式就无法注册的app，如果你对隐私要求很高，那么就放弃别用吧！或者就是注册一个北美虚拟号，当然国内的app不支持米国虚拟号。其实用手机注册还有一个口怕的地方。又举个栗子啊，记得鹅厂（QQ）有个功能是通过你的好友找到好友，是不是好神奇？假如某个不良app上传了你的通讯录，你的另外一个未知朋友也上传了通讯录，那么是不是可以通过算法找到你朋友的朋友？假如你用的这个app，哪天被入侵了，黑阔是不是就把你的朋友关系全部都拿到了？那么你的朋友也因为你的上传通讯录受到骚扰哦，如果你非用不可那么晚只能建议用一些大公司的app，因为他们有专业的安全评估人员。 相对风险比较低一些！
0x04 我啰嗦了半天，貌似解决方案还没给出来呢，好吧，那我就把我管理密码的方式给大家说说了，主要是两种：
使用开源的密码管理工具keepassx，因为它可以win+linux+android 平台使用，本人太屌丝，没有用过Mac和iOS所以还不知道苹果上用哪个比较靠谱！ 对于我比较重要的帐号我开通了两步验证。(其实我一直想写一个两步验证的服务器，提供相关的api给大家用，只是不知道google的那个算法，有知道的大神速度发链接呀！) 补充：对于那种你觉得不靠谱的网站建议备用一个随机的邮箱来注册（如：dhdjsie3hs@gmail.com)，然后将这歌随机邮箱的信息自动的转发到你某个邮箱中！
好了相关帐号密码的我就说到这吧，关于隐私还有很多，期待我的下一篇博文吧！</description></item><item><title>浅谈Http API验证</title><link>https://youkale.github.io/posts/http-api-auth/</link><pubDate>Sat, 21 Nov 2015 13:28:00 +0000</pubDate><guid>https://youkale.github.io/posts/http-api-auth/</guid><description>前言 目前web应用主要面临的安全问题：
数据篡改
数据窃取
重放攻击
非法参数提交 （SQL注入,XSS等）.
防范 好了既然问题那么多，我们怎么其防范呢？经常在网上下东西的人可能会碰到这样的情况，就是你下载的资源会对应一个checksum.用这个校验码来确定本次你下载的东西，在下载过程中没有被人篡改，这个就叫数字签名。可能有人要问了，我们说的是HTTP验证的东西，跟这个有半毛钱的关系呀？聪明的朋友可能想到了，假如我们把每个HTTP请求都加上一个数字签名，那么数据篡改的问题是不是就可以避免的呢？答案是肯定可以的，因为HTTP请求验证方式中，有一种方式就是数字签名（http digest auth）。亚马逊很多校验请求用的就是这个方式。这种方式简单的说，就是客户端和服务端通过一些随机数+请求参数+URL+头部+时间戳等信息通过hash算法生成一个checksum，发送给接收端，接受端同样采用相同的算法，计算checksum是否一致来确定本次请求过程中数据有没有被篡改，从而保证了请求的合法性。
实施 上面说的这个原理中主要包含几个要素：
key：
这个key只能是客户端和服务端知道，否则无法保证请求的合法性验证了。key的生成方式可以根据应用来区分：
传统web应用：服务器可以根据客户端浏览器的信息，结合请求的IP，User-Agent等信息产生一个key。
移动APP应用：可以通过事先约定key的方式（前提不能被反编译），或者通过一些非对称加密来生成一个key
总的一点就是：这个key很重要，不能泄漏出去，上面的两个方法可以用来参考，如果看官们又更好的方法，欢迎讨论。
Header:
比如请求方法呀，请求路径之类的.
参数：
构成本次合法请求的参数。
时间戳 ：
其实这个时间戳主要是用来防止重放攻击的。服务器端和客户端可以约定一个请求时间范围。超过这个时间段属于是非法请求。
接着我们将上面的三个元素通过一些不可逆的算法生成一个checksum，
如：hmac(key + header + params + ts + &amp;hellip;)
然后连同参数（URL，表单信息，sessionid等）信息一同传递给接收端，接收端根据相同的规则对数据进行验证。
展开思路 因为每个请求都有唯一的checksum,那么我们可以在这个基础上加上鉴权功能，如某个Appid只能访问某个path
总结 上面方法中能保证的安全有两部分： 1,数据防篡改 2,重放攻击 要需要防止数据窃取，还是需要将https加入进来。 关于非法数据引起的一些问题，想必开发们也都碰到过，如果是防止sql注入最好在前端做一次参数检查，后端参数检查，用sql参数化的方式。xss攻击也是需要在各个点进行参数检查。
总的来说知道各种安全问题，才能写出健壮的程序来。</description></item><item><title>破解房东网络</title><link>https://youkale.github.io/posts/crack-landlord-networks/</link><pubDate>Sat, 21 Nov 2015 03:18:43 +0000</pubDate><guid>https://youkale.github.io/posts/crack-landlord-networks/</guid><description>前言: 最近搬到一个新地方,没有网,对于一个程序员没有网络是多么痛苦的一件事情呀. 还好房东留下了一个RJ-45的网络接口.哈哈哈哈,这不是给我机会了么? 好,立马插入网线来看看有没什么可以好玩的东西.
开始干活: 插入DHCP发现就获取到了IP
$ ifconfig eth0 Link encap:Ethernet HWaddr C6:D6:06:33:xx:xx inet addr:192.169.31.23 Bcast:192.169.30.255 Mask:255.255.255.0 inet6 addr: fe80::c4d6:6ff:fe33:933b/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:25961173 errors:0 dropped:17 overruns:0 frame:0 TX packets:18604131 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:27916381007 (25.9 GiB) TX bytes:1554819614 (1.4 GiB) 看看路由信息
$ route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 192.169.30.1 0.0.0.0 UG 0 0 0 eth0 192.</description></item></channel></rss>