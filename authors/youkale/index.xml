<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Youkale on (-> c r u d)</title><link>https://youkale.github.io/authors/youkale/</link><description>Recent content in Youkale on (-> c r u d)</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sat, 11 Jun 2022 12:32:29 +0800</lastBuildDate><atom:link href="https://youkale.github.io/authors/youkale/index.xml" rel="self" type="application/rss+xml"/><item><title>SSH常见用法</title><link>https://youkale.github.io/posts/ssh_cmd_example/</link><pubDate>Sat, 11 Jun 2022 12:32:29 +0800</pubDate><guid>https://youkale.github.io/posts/ssh_cmd_example/</guid><description>分享一些常见用法，希望能在工作中能提高效率。
涵盖以下内容: .ssh/config 配置
常用映射
远程-&amp;gt;本地 -L 本地-&amp;gt;远程 -R 动态代理 -D 其他ssh命令集
scp ssh-copy-id ssh-keygen .ssh/config配置简要说明 ### ----------- ~/.ssh/config ----------- Host server_1 ## 你配置的服务器名称，可根据自己的喜好配置 HostName 223.5.5.5 ## ip 或者 domain, 可以访问的地址 User ubuntu ## 默认使用的用户名 Port 22 ## 服务器端口 IdentityFile ~/.ssh/server_rsa ## rsa私钥地址 ProxyCommand nc -X 5 -x 127.0.0.1:8106 %h %p ## 代理配置, 表示通过本地 socksv5 服务器进行代理 ### 接下来可以直接在终端下面这样使用: ### ----------- 使用方法 ----------- ~$ ssh server_1 跳板机例子: ### ----------- ~/.ssh/config ----------- Host jump HostName 223.</description></item><item><title>线上服务器TCP连接相关优化</title><link>https://youkale.github.io/posts/online-server-tcp-connect-optimization/</link><pubDate>Mon, 06 Jun 2022 12:32:29 +0800</pubDate><guid>https://youkale.github.io/posts/online-server-tcp-connect-optimization/</guid><description>线上服务器TCP连接相关 为什么优化点在网络？ 随着云平台的兴起, 传统自建数据库或者其他业务中间件的情况会比较少，而我们系统也主要集中在调用平台提供的服务。
因此今天主要讲的是网络相关内容。
TCP-4次挥手 alice --&amp;gt; bob: FIN [1] alice --&amp;gt; alice: FIN_WAIT_1 [2] bob -- alice: ACK [3] alice -- alice: FIN_WAIT_2 bob --&amp;gt; bob: CLOSE_WAIT bob --&amp;gt; alice: FIN ACK bob --&amp;gt; bob: LAST_ACK alice --&amp;gt; bob: ACK alice -- alice: TIME_WAIT, 等待2MSL bob --&amp;gt; bob: 关闭 alice --&amp;gt; alice: 2MSL关闭 alice -&amp;gt; bob: 分手吧。 (fin_wait_1) bob -&amp;gt; alice: ok (close_wait) alice: (fin_wait_2) bob -&amp;gt; alice: 来呀，分手吧, (last_ack) alice -&amp;gt; bob: ok ，(TIME-WAIT + 2MSL) bob: CLOSE 为什么在排查TCP连接的时候要去检查TIME-WAIT?</description></item><item><title>如何设计RESTful API</title><link>https://youkale.github.io/posts/how-to-design-restful-api/</link><pubDate>Sat, 21 May 2022 12:32:29 +0800</pubDate><guid>https://youkale.github.io/posts/how-to-design-restful-api/</guid><description>什么是REST Wiki中REST全称是 (Representational State Transfer) &amp;ldquo;表现层状态转换&amp;rdquo;, 也有翻译是“表征状态转移”，是Roy Thomas Fielding博士在2000年提出的一种基于Http协议的软件架构风格。表征状态转移,听起来很晦涩，是因为前面主语 Resource 被去掉了，真正的全称是 Resource Representational State Transfer 也就是: 资源在网络中以某种表现形式进行状态转移。
Resource：资源，即数据（前面说过网络的核心）。比如 users，corp等； Representational：某种表现形式，比如用JSON，XML，JPEG等； State Transfer：状态变化。通过HTTP动词实现。 REST等级 Level-0 The Ramp of Plain Old XML 说明 服务端使用统一的请求路径，通过请求体中某个字段定义业务类型，需要定义错误码。
调用 对照文档中 action 类型进行传参, 同时对响应错误码进行处理。
POST /server Content-Type: Application/json { &amp;#34;action&amp;#34;:&amp;#34;001&amp;#34;, &amp;#34;data&amp;#34;: { &amp;#34;username&amp;#34;:&amp;#34;...&amp;#34;, } } ----- Response ----- Status: 200 Content-Type: application/json { &amp;#34;status&amp;#34;: &amp;#34;A00001&amp;#34; &amp;#34;data&amp;#34;: { .... } } Level-1 Resource: 引入资源的RPC 说明 在微服务盛行的今天，引入了URI，方便网关层对请求进行转发，同时能通过URI能反映出对应的业务，需要定义错误码。
调用 对照文档中资源动作，进行传递参数，同时对响应错误码进行处理。</description></item><item><title>Vue3 Typescript LogicFlow 通过H函数自定义HTML节点</title><link>https://youkale.github.io/posts/vue3-ts-logicflow-custorm-html-node/</link><pubDate>Mon, 21 Mar 2022 12:32:29 +0800</pubDate><guid>https://youkale.github.io/posts/vue3-ts-logicflow-custorm-html-node/</guid><description> 问题 在使用DiDi的LogicFlow中，因为使用的是最新的VUE3+TS，官方没有相关的文档，在自定义HTML Node的时候碰到了一下问题，最终通过翻阅VUE3的文档找到了如下的解决方法
import { HtmlNode, HtmlNodeModel } from &amp;#39;@logicflow/core&amp;#39;; import { defineComponent, h, render as vueRender } from &amp;#39;vue&amp;#39;; import { Button, Card } from &amp;#39;ant-design-vue&amp;#39;; const myHtmlNode = defineComponent({ name: &amp;#39;MyHtmlNode&amp;#39;, components: { &amp;#39;a-button&amp;#39;: Button, //需要重新引入组件 &amp;#39;a-card&amp;#39;: Card, //需要重新引入组件 }, template: ` &amp;lt;div&amp;gt; &amp;lt;a-button type=&amp;#34;primary&amp;#34; @click=&amp;#34;handle(&amp;#39;plus&amp;#39;)&amp;#34;&amp;gt;+&amp;lt;/a-button&amp;gt; &amp;lt;a-button type=&amp;#34;dashed&amp;#34; @click=&amp;#34;handle(&amp;#39;sub&amp;#39;) &amp;#34;&amp;gt;-&amp;lt;/a-button&amp;gt; &amp;lt;/div&amp;gt; `, setup() const _handleClick = (action) =&amp;gt; { console.log(`action ....${action}`); }; return { handle: _handleClick, }; }, }); class PluginNode extends HtmlNode { setHtml(rootEl: HTMLElement) { const vm = h(myHtmlNode, {}); vueRender(vm, rootEl); } }</description></item><item><title>clojure支持参数重载的宏</title><link>https://youkale.github.io/posts/make-clojure-overload-definline/</link><pubDate>Thu, 21 Oct 2021 12:32:29 +0800</pubDate><guid>https://youkale.github.io/posts/make-clojure-overload-definline/</guid><description> 问题 通过clojure.core/definline可以以方法的形态定义一个宏，但是definline这个宏却只支持固定的参数，在某些情况下需要支持不同参数的宏，从java的角度来说就是方法重载了。
支持重载的definline 大部分代码都是在definline的基础上魔改的。
(defmacro definline+ [name &amp;amp; decl] (let [body (map (fn [[args# expr#]] (let [f# (apply (eval (list `fn (list args# expr#))) args#)] `(~args# ~f#))) decl) alt-body (map (fn [[args# expr#]] `(~args# ~expr#)) decl)] `(do (defn ~name ~@body) (alter-meta! (var ~name) assoc :inline (fn ~name ~@alt-body)) (var ~name))))])))])) 使用 比如noop 方法，现在可以支持2、3个参数了。
(definline+ noop ([a b] (or ~a ~b)) ([a b c] (or ~a ~b ~c)))</description></item></channel></rss>