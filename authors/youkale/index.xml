<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Youkale on (-> c r u d)</title><link>https://youkale.github.io/authors/youkale/</link><description>Recent content in Youkale on (-> c r u d)</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Mon, 06 Jun 2022 12:32:29 +0800</lastBuildDate><atom:link href="https://youkale.github.io/authors/youkale/index.xml" rel="self" type="application/rss+xml"/><item><title>线上服务器TCP连接相关优化</title><link>https://youkale.github.io/posts/online-server-tcp-connect-optimization/</link><pubDate>Mon, 06 Jun 2022 12:32:29 +0800</pubDate><guid>https://youkale.github.io/posts/online-server-tcp-connect-optimization/</guid><description>线上服务器TCP连接相关 为什么优化点在网络？ 随着云平台的兴起, 传统自建数据库或者其他业务中间件的情况会比较少，而我们系统也主要集中在调用平台提供的服务。
因此今天主要讲的是网络相关内容。
TCP-4次挥手 alice --&amp;gt; bob: FIN [1] alice --&amp;gt; alice: FIN_WAIT_1 [2] bob -- alice: ACK [3] alice -- alice: FIN_WAIT_2 bob --&amp;gt; bob: CLOSE_WAIT bob --&amp;gt; alice: FIN ACK bob --&amp;gt; bob: LAST_ACK alice --&amp;gt; bob: ACK alice -- alice: TIME_WAIT, 等待2MSL bob --&amp;gt; bob: 关闭 alice --&amp;gt; alice: 2MSL关闭 alice -&amp;gt; bob: 分手吧。 (fin_wait_1) bob -&amp;gt; alice: ok (close_wait) alice: (fin_wait_2) bob -&amp;gt; alice: 来呀，分手吧, (last_ack) alice -&amp;gt; bob: ok ，(TIME-WAIT + 2MSL) bob: CLOSE 为什么在排查TCP连接的时候要去检查TIME-WAIT?</description></item><item><title>Vue3 Typescript LogicFlow 通过H函数自定义HTML节点</title><link>https://youkale.github.io/posts/vue3-ts-logicflow-custorm-html-node/</link><pubDate>Mon, 21 Mar 2022 12:32:29 +0800</pubDate><guid>https://youkale.github.io/posts/vue3-ts-logicflow-custorm-html-node/</guid><description> 问题 在使用DiDi的LogicFlow中，因为使用的是最新的VUE3+TS，官方没有相关的文档，在自定义HTML Node的时候碰到了一下问题，最终通过翻阅VUE3的文档找到了如下的解决方法
import { HtmlNode, HtmlNodeModel } from &amp;#39;@logicflow/core&amp;#39;; import { defineComponent, h, render as vueRender } from &amp;#39;vue&amp;#39;; import { Button, Card } from &amp;#39;ant-design-vue&amp;#39;; const myHtmlNode = defineComponent({ name: &amp;#39;MyHtmlNode&amp;#39;, components: { &amp;#39;a-button&amp;#39;: Button, //需要重新引入组件 &amp;#39;a-card&amp;#39;: Card, //需要重新引入组件 }, template: ` &amp;lt;div&amp;gt; &amp;lt;a-button type=&amp;#34;primary&amp;#34; @click=&amp;#34;handle(&amp;#39;plus&amp;#39;)&amp;#34;&amp;gt;+&amp;lt;/a-button&amp;gt; &amp;lt;a-button type=&amp;#34;dashed&amp;#34; @click=&amp;#34;handle(&amp;#39;sub&amp;#39;) &amp;#34;&amp;gt;-&amp;lt;/a-button&amp;gt; &amp;lt;/div&amp;gt; `, setup() const _handleClick = (action) =&amp;gt; { console.log(`action ....${action}`); }; return { handle: _handleClick, }; }, }); class PluginNode extends HtmlNode { setHtml(rootEl: HTMLElement) { const vm = h(myHtmlNode, {}); vueRender(vm, rootEl); } }</description></item><item><title>clojure支持参数重载的宏</title><link>https://youkale.github.io/posts/make-clojure-overload-definline/</link><pubDate>Thu, 21 Oct 2021 12:32:29 +0800</pubDate><guid>https://youkale.github.io/posts/make-clojure-overload-definline/</guid><description> 问题 通过clojure.core/definline可以以方法的形态定义一个宏，但是definline这个宏却只支持固定的参数，在某些情况下需要支持不同参数的宏，从java的角度来说就是方法重载了。
支持重载的definline 大部分代码都是在definline的基础上魔改的。
(defmacro definline+ [name &amp;amp; decl] (let [body (map (fn [[args# expr#]] (let [f# (apply (eval (list `fn (list args# expr#))) args#)] `(~args# ~f#))) decl) alt-body (map (fn [[args# expr#]] `(~args# ~expr#)) decl)] `(do (defn ~name ~@body) (alter-meta! (var ~name) assoc :inline (fn ~name ~@alt-body)) (var ~name))))])))])) 使用 比如noop 方法，现在可以支持2、3个参数了。
(definline+ noop ([a b] (or ~a ~b)) ([a b c] (or ~a ~b ~c)))</description></item></channel></rss>